CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
828,Signal Handler with Functionality that is not Asynchronous-Safe,Variant,Incomplete,"The product defines a signal handler that contains code sequences that are not asynchronous-safe, i.e., the functionality is not reentrant, or it can be interrupted.","This can lead to an unexpected system state with a variety of potential consequences depending on context, including denial of service and code execution. Signal handlers are typically intended to interrupt normal functionality of a program, or even other signals, in order to notify the process of an event. When a signal handler uses global or static variables, or invokes functions that ultimately depend on such state or its associated metadata, then it could corrupt system state that is being used by normal functionality. This could subject the program to race conditions or other weaknesses that allow an attacker to cause the program state to be corrupted. While denial of service is frequently the consequence, in some cases this weakness could be leveraged for code execution. There are several different scenarios that introduce this issue: Invocation of non-reentrant functions from within the handler. One example is malloc(), which modifies internal global variables as it manages memory. Very few functions are actually reentrant. Code sequences (not necessarily function calls) contain non-atomic use of global variables, or associated metadata or structures, that can be accessed by other functionality of the program, including other signal handlers. Frequently, the same function is registered to handle multiple signals. The signal handler function is intended to run at most one time, but instead it can be invoked multiple times. This could happen by repeated delivery of the same signal, or by delivery of different signals that have the same handler function (CWE-831). Note that in some environments or contexts, it might be possible for the signal handler to be interrupted itself. If both a signal handler and the normal behavior of the product have to operate on the same set of state variables, and a signal is received in the middle of the normal execution's modifications of those variables, the variables may be in an incorrect or corrupt state during signal handler execution, and possibly still incorrect or corrupt upon return.",::NATURE:ChildOf:CWE ID:364:VIEW ID:1000:ORDINAL:Primary::,,,,,,,,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:NOTE:The most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure.::",,"::PHASE:Implementation Architecture and Design:DESCRIPTION:Eliminate the usage of non-reentrant functionality inside of signal handlers. This includes replacing all non-reentrant library calls with reentrant calls. Note: This will not always be possible and may require large portions of the product to be rewritten or even redesigned. Sometimes reentrant-safe library alternatives will not be available. Sometimes non-reentrant interaction between the state of the system and the signal handler will be required by design.:EFFECTIVENESS:High::PHASE:Implementation:DESCRIPTION:Where non-reentrant functionality must be leveraged within a signal handler, be sure to block or mask signals appropriately. This includes blocking other signals within the signal handler itself that may also leverage the functionality. It also includes blocking all signals reliant upon the functionality when it is being accessed or modified by the normal behaviors of the product.::","::REFERENCE:CVE-2008-4109:DESCRIPTION:Signal handler uses functions that ultimately call the unsafe syslog/malloc/s*printf, leading to denial of service via multiple login attempts:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4109::REFERENCE:CVE-2006-5051:DESCRIPTION:Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).:LINK:https://www.cve.org/CVERecord?id=CVE-2006-5051::REFERENCE:CVE-2001-1349:DESCRIPTION:unsafe calls to library functions from signal handler:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1349::REFERENCE:CVE-2004-0794:DESCRIPTION:SIGURG can be used to remotely interrupt signal handler; other variants exist.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0794::REFERENCE:CVE-2004-2259:DESCRIPTION:SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2259::REFERENCE:CVE-2002-1563:DESCRIPTION:SIGCHLD not blocked in a daemon loop while counter is modified, causing counter to get out of sync.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1563::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:SIG31-C:ENTRY NAME:Do not access or modify shared objects in signal handlers::,,,
