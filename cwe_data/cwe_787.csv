CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
787,Out-of-bounds Write,Base,Draft,"The product writes data past the end, or before the beginning, of the intended buffer.",,::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,"::ORDINALITY:Resultant:DESCRIPTION:At the point when the product writes data to an invalid location, it is likely that a separate weakness already occurred earlier. For example, the product might alter an index, perform incorrect pointer arithmetic, initialize or release memory incorrectly, etc., thus referencing a memory location outside the buffer.::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::,,"::TERM:Memory Corruption:DESCRIPTION:Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.::",::PHASE:Implementation::,,,"::SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:Write operations could cause memory corruption. In some cases, an adversary can modify control data such as return addresses in order to execute unexpected code.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Attempting to access out-of-range, invalid, or unauthorized memory could cause the product to crash.::SCOPE:Other:IMPACT:Unexpected State:NOTE:Subsequent write operations can produce undefined or unexpected results.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Operation Build and Compilation:STRATEGY:Environment Hardening:DESCRIPTION:Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that the buffer is as large as specified. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation Build and Compilation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::","::REFERENCE:CVE-2023-1017:DESCRIPTION:The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.:LINK:https://www.cve.org/CVERecord?id=CVE-2023-1017::REFERENCE:CVE-2021-21220:DESCRIPTION:Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-21220::REFERENCE:CVE-2021-28664:DESCRIPTION:GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-28664::REFERENCE:CVE-2020-17087:DESCRIPTION:Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-17087::REFERENCE:CVE-2020-1054:DESCRIPTION:Out-of-bounds write in kernel-mode driver, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-1054::REFERENCE:CVE-2020-0041:DESCRIPTION:Escape from browser sandbox using out-of-bounds write due to incorrect bounds check, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-0041::REFERENCE:CVE-2020-0968:DESCRIPTION:Memory corruption in web browser scripting engine, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-0968::REFERENCE:CVE-2020-0022:DESCRIPTION:chain: mobile phone Bluetooth implementation does not include offset when calculating packet length (CWE-682), leading to out-of-bounds write (CWE-787):LINK:https://www.cve.org/CVERecord?id=CVE-2020-0022::REFERENCE:CVE-2019-1010006:DESCRIPTION:Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).:LINK:https://www.cve.org/CVERecord?id=CVE-2019-1010006::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1532::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0269::REFERENCE:CVE-2002-2227:DESCRIPTION:Unchecked length of SSLv2 challenge value leads to buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2227::REFERENCE:CVE-2007-4580:DESCRIPTION:Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4580::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4268::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2403::",,,::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 3.5::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SI-1::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SI-2::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SVV-1::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SVV-3::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 3.5::,,,
