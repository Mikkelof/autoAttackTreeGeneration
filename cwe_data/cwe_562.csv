CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
562,Return of Stack Variable Address,Base,Draft,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.","Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",::NATURE:ChildOf:CWE ID:758:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:672:VIEW ID:1000::NATURE:CanPrecede:CWE ID:825:VIEW ID:1000::,::ORDINALITY:Indirect::ORDINALITY:Primary::,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation::,,,"::SCOPE:Availability:SCOPE:Integrity:SCOPE:Confidentiality:IMPACT:Read Memory:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:DoS: Crash, Exit, or Restart:NOTE:If the returned stack buffer address is dereferenced after the return, then an attacker may be able to modify or read memory, depending on how the address is used. If the address is used for reading, then the address itself may be exposed, or the contents that the address points to. If the address is used for writing, this can lead to a crash and possibly code execution.::","::METHOD:Fuzzing:DESCRIPTION:Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::",::PHASE:Testing:DESCRIPTION:Use static analysis tools to spot return of the address of a stack variable.::,,,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:DCL30-C:ENTRY NAME:Declare objects with appropriate storage durations:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:POS34-C:ENTRY NAME:Do not call putenv() with a pointer to an automatic variable as the argument::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::,,,
