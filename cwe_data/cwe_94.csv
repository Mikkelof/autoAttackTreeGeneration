CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
94,Improper Control of Generation of Code ('Code Injection'),Base,Draft,"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.","When a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution. Injection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:913:VIEW ID:1000::,,::LANGUAGE CLASS:Interpreted:LANGUAGE PREVALENCE:Sometimes::TECHNOLOGY NAME:AI/ML:TECHNOLOGY PREVALENCE:Undetermined::,,,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:In some cases, injectable code controls authentication; this may lead to a remote vulnerability.::SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:NOTE:Injected code can access resources that the attacker is directly prevented from accessing.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:Often the actions performed by injected control code are unlogged.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design:DESCRIPTION:Refactor your program so that you do not have to dynamically generate code.::PHASE:Architecture and Design:DESCRIPTION:Run your code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product. Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().::PHASE:Testing:DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::PHASE:Testing:DESCRIPTION:Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::PHASE:Operation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Implementation:DESCRIPTION:For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].:EFFECTIVENESS:Discouraged Common Practice::","::REFERENCE:CVE-2023-29374:DESCRIPTION:Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a prompt injection attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2023-29374::REFERENCE:CVE-2024-5565:DESCRIPTION:Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a prompt injection attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2024-5565::REFERENCE:CVE-2024-4181:DESCRIPTION:Framework for LLM applications allows eval injection via a crafted response from a hosting provider.:LINK:https://www.cve.org/CVERecord?id=CVE-2024-4181::REFERENCE:CVE-2022-2054:DESCRIPTION:Python compiler uses eval() to execute malicious strings as Python code.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-2054::REFERENCE:CVE-2021-22204:DESCRIPTION:Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22204::REFERENCE:CVE-2020-8218:DESCRIPTION:Code injection in VPN product, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-8218::REFERENCE:CVE-2008-5071:DESCRIPTION:Eval injection in PHP program.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5071::REFERENCE:CVE-2002-1750:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1750::REFERENCE:CVE-2008-5305:DESCRIPTION:Eval injection in Perl program using an ID that should only contain hyphens and numbers.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5305::REFERENCE:CVE-2002-1752:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1752::REFERENCE:CVE-2002-1753:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1753::REFERENCE:CVE-2005-1527:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1527::REFERENCE:CVE-2005-2837:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2837::REFERENCE:CVE-2005-1921:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1921::REFERENCE:CVE-2005-2498:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2498::REFERENCE:CVE-2005-3302:DESCRIPTION:Code injection into Python eval statement from a field in a formatted file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3302::REFERENCE:CVE-2007-1253:DESCRIPTION:Eval injection in Python program.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1253::REFERENCE:CVE-2001-1471:DESCRIPTION:chain: Resultant eval injection. An invalid value prevents initialization of variables, which can be modified by attacker and later injected into PHP eval statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1471::REFERENCE:CVE-2002-0495:DESCRIPTION:Perl code directly injected into CGI library file from parameters to another CGI program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0495::REFERENCE:CVE-2005-1876:DESCRIPTION:Direct PHP code injection into supporting template file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1876::REFERENCE:CVE-2005-1894:DESCRIPTION:Direct code injection into PHP script that can be accessed by attacker.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1894::REFERENCE:CVE-2003-0395:DESCRIPTION:PHP code from User-Agent HTTP header directly inserted into log file implemented as PHP script.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0395::",,,::TAXONOMY NAME:PLOVER:ENTRY ID:CODE:ENTRY NAME:Code Evaluation and Injection::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 3.5::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 3.5::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SVV-1::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SVV-3::,::242::35::77::,,
